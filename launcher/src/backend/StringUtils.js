const log = require("electron-log");
import * as crypto from "crypto";
import { Base64 } from "@/share/Base64";

export class StringUtils {
  static escapeStringForShell(shellCmd) {
    log.debug("received: ", shellCmd);

    let escapedShellCmd = "";
    if (shellCmd) {
      escapedShellCmd = '"' + shellCmd.replace(/(["$`\\])/g, "\\$1") + '"';
    }

    log.debug("escaped: ", escapedShellCmd);

    return escapedShellCmd;
  }

  static createRandomString() {
    const randomString = crypto.randomBytes(18).toString("hex");
    let result = "";
    for (let i = 0; i < 36; i++) {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        result += "-";
      } else {
        result += randomString[i];
      }
    }
    return result;
  }

  /**
   * Returns true if str is base64 encoded
   */
  static isBase64(str, enc = "utf8") {
    return Base64.validate(str, enc);
  }

  /**
   * Decode base64 encoded string
   */
  static base64decode(str, enc = "utf8") {
    return Base64.decode(str, enc);
  }

  /**
   * Encode string to base64
   */
  static base64encode(str, enc = "utf8") {
    return Base64.encode(str, enc);
  }

  /**
   * Get SSV public key from secret key
   */
  static getSSVPublicKeyFromSecretKey(secret_key, raw = false, enc = "utf8") {
    // Decode the base64 encoded SSV secret_key and get the RSA key in PEM format
    const rsa_public_key = this.getRsaPublicKeyFromPrivateKey(secret_key, enc);

    // RSA keys in PEM format that are generated by SSV are usually starting/ending
    // with 'START RSA PUBLIC KEY' / ' END RSA PUBLIC KEY' while RSA keys generated
    // via crypto lib start/end with 'START PUBLIC KEY' / ' END PUBLIC KEY'.
    // Technically it does not matter but it is better to get the exact same base64
    // encoded result as the user would get from SSV (to avoid confusion)
    const rsa_public_key_ssv_style = rsa_public_key.replace(/(BEGIN|END) (PUBLIC.*)/g, "$1 RSA $2");

    // Return the Base64 econded (or raw) RSA key
    return !raw ? this.base64encode(rsa_public_key_ssv_style) : rsa_public_key_ssv_style;
  }

  /**
   * Get RSA public key from private key
   */
  static getRsaPublicKeyFromPrivateKey(private_key) {
    try {
      if (this.isBase64(private_key)) private_key = this.base64decode(private_key);

      const pubKeyObject = crypto.createPublicKey({
        key: private_key,
        format: "pem",
      });

      const publicKey = pubKeyObject.export({
        format: "pem",
        type: "spki",
      });

      return publicKey;
    } catch (err) {
      log.error("Can't create RSA public key from RSA private key ", err);
      throw new Error("Can't create RSA public key from RSA private key : " + err);
    }
  }

  /**
   * Return true if given public_key is a valid RSA public key in PEM format
   */
  static isValidRsaPublicKey(public_key) {
    //eturn crypto.verifyPublicKey(public_key, "pem", "rsa"); // true/false
    return public_key.includes("PUBLIC KEY");
  }

  /**
   * Return true if given private_key is a valid RSA private key in PEM format
   */
  static isValidRsaPrivateKey(private_key) {
    //return crypto.verifyPrivateKey(private_key, "pem", "rsa"); // true/false
    return private_key.includes("PRIVATE KEY");
  }
}
